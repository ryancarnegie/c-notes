%s13 is saying it's a field size of 13 that'll be displayed.


Conversion types
-------------------
Data type	printf conversion specification		scanf conversion specification
long double	%lf					%Lf
double 		%f					%lf
float		%f					%f

Integer types
Data type		printf conversion specification		scanf conversion specification
unsigned long long int	%llu					%llu
long long int		%lld					%lld
unsigned long int	%lu					%lu
long int		%ld					%ld
unsigned int		%u					%u
int 			%d					%d
unsigned short		%hu					%hu
short			%hd					%hd
char			%c					%c

double and float are the same with a print conversion specification in C.
They are not the same for scanf. They have to be different, and that is because what you pass to
scanf is an address, and you can't tell by looking at the address whether it's a double or a float.
It tells whether it's a double or a float by the conversion specification. 
scanf is given an address with the address of operator. 
array names are pointers.


sizeof long double returns an integer value.
sizeof returns the size of something in bytes. an object's or type's size in bytes.
sizeof returns as a sze_t value the array's total number of bytes.
sizeof is a compile-time operator, so it does not incur any execution-time overhead (except for VLAs).


Random Facts
-------------------
Inline option is available in C and C++ as well.

int maximum(int x, int y, int z);
The parameters to maximum are three ints.
scanf("%d%d%d", &number1, &number2, &number3);
The arguments to maximum in main when we invoke or call it are number1, number2, and number3.
The values passed are the arguments, the type that the function is expecting is the parameters.
The parameters are through the ints of this function prototype.
The 3 arguments passed to maximum are passed by value. 
printf("Maximum is: %d\n", maximum(number1, number2, number3);
Maximum returns 1 int, so it prints 1 int with %d. It will return the max of the three values.

When you pass by value you are passing a copy, not the original.
When you pass by reference you pass the original.
If I give a friend a 1000 dollar bill that asks to see it, I give him the 1000 dollar bill.
That is passed by reference, because I gave him the original 1000 dollar bill. Once he is done
with the bill, another person overhears this conversation and asks to see the 1000 dollar bill.
I do not know this person and do not trust them compared to my friend, so I give him a photocopy
of the 1000 dollar bill, and I give him the copy. That is passed by value.  
In C the only way you can pass by reference is by using pointers.
Array names are pointers. 


Storage Classes
-------------------
C provides storage-class specifiers
	auto
	register
	extern
	static
A storage class determines an identifier's storage duration, scope, and linkage.
Storage duration is the period during which an identifier exists in memory.
Scope determines where a program can reference an identifier.
Labels are identifiers followed by a colon such as start:
Labels are the only thing that have function scope. Labels are used in goto statements.



Function Prototypes
-------------------
int square(int number);  // function prototype
The prototype only says what the name of the function is, what the parameters are,
what type they are and what order they are if there's more than one, 
example int and a double, and what type is returned. 
	- what the name of the function is
	- what the parameters are
	- what type is returned

int square(int number) { // implementation below main
	return number * number;
}
The prototype is only necessary if the implementation is below the main.
If the implementation is above the main, the prototype is not necessary.
The compiler would know all about the function including what it does.
Functions can be implemented in separate .c files.


size_t
-----
char and integer are compatible. All characters are an integer value of 0 to 128 for the normal ascii character values as an unsigned integer.
size_t represents an unsigned integral type recommended for variables representing an array's size or subscripts
size_t is defined in header <stddef.h>
size_t is converted with specificion %zu

char c one spot in memory - add 3 characters into that and it does out of bounds. 
getchar() returns 1 character. 
int s = 13; // type 13 things
int x;
while (s--) {
  x = getchar(x);
putchar(x);
}

getchar() gives back the ASCII code of the character that it returned. it returns 1 integer. 
However, if multiple characters are pressed, it will stack them up until the end of file, which is character ascii value 10. 
Return -1 in C means it didn't find anything, therefore a bad character.

Double quotes for string literals. Single quotes for single character.
int n[SIZE] = { 12, 15, 11, 7, 16 };
printf("%s%13s%17s\n", "Element", "Value", "Bar Chart\n");
for (size_t i = 0; i < SIZE; i++) { // size_t for the array.
	printf("%7zu%13d%8s", i, n[i], "");
	for (int j = 1; j <= n[i]; ++j) {
		printf("%c", '*');
	}
}





Random 
----------------
Random in C - included in <stdlib.h> library
scale	shift 	1-6
rand()%6 // rand modulus 6 add one
// Whatever the mod number is is how many numbers you will generate.
rand()%6 + 1
0 <------> 5
v	   v
1 <------> 6
for (int i = 5; i <= 5; i++) {
	printf("%d ", 1 + (rand() % 6)); // output 6 6 5 5 6 every time
} 
// having the same output can be a good thing for debugging.
We get the same results every time we run it because we are running the exact same code.
Even though this rand is supposed to be generating random values, and to some degree it
does, it's generating the same random values every time. 
When rand is invoked the first time, it produces a random number.
It uses a formula, a table lookup, and it also uses the seed.
rand() --> rand #1 
rand() --> rand #2 // uses the same formula, uses the same table, but does not use the same seed.
// #2 uses the seed as the previous seed
rand() --> rand #3 // when called the third time, it uses the same seed as #2
These rands produce the original value produced by rand, before doing any scaling on it.

If you need to seed the random number generator, only do it once at the top.
printf("%s", "Enter seed: ");
int seed = 0;
scanf("%d", &seed);
srand(seed); // seed the random number generator
To randomize without entering a seed each time, use a statement like:
srand(time(NULL));
This causes the computer to read its clock to obtain the value for a seed automatically.
Function time returns the number of seconds that have passed since midnight on January 1st, 1970.
The function prototype for time is in <time.h>


5 <---------------> 20
If you want random values between 5 and 20, subject the smaller from the larger, it would be 15.
It's not 15, it is 16. 
rand() % 16 // values from 0 to 15. It adds 1.
0 <---------------> 15
rand() % 16 + 5
5 <---------------> 20

-5 to +5
rand() % 11 // 11 values in total including 0. 0 counts as one of the values.
-5 to +5 needs 10 + 1 values to include the 0.
rand() % 11
0 <--------> 10 // this gives us 0 to 10, but we want -5 to +5.
Subtract 5
-5 <-------> 5
rand() % 11 - 5

3, 5, 7, 9, 11 // I want to randomly generate these values.
rand() % 5 // count the total number of values on the line above.
0, 1, 2, 3, 4  // these are the values that we now have with % 5.
But we want 3, 5, 7, 9, and 11.
Multiply the modulos 5 by 2.
0, 2, 4, 6, 8
Then add 3.
1, 5, 7, 9, 11
rand() % 5 * 2 + 3;





Function Pointers
-----------------
int sum(int x, int y) {
  return x + y;
}

int prod(int x, int y) {
  return x * y;
}

void shoudNotBeChanged(int (*operation)(int, int)) {
  srand(time(NULL));
  int a = rand() % 100;
  int b = rand() % 100;
  printf("Result between %d and %d is %d\n", a, b, operation(a, b));
}

int main() {
  shouldNotBeChanged(*sum);
}
-----------------





Pointer Arithmetic Operators
-----------------
Assigning Pointers to one another
	* Pointers of the same type may be assigned to one another
int arr[20] = {5, 10, 15, ...};
index 	0	1	2	3	4	5	6
arr	5, 	10, 	15, 	20, 	25, 	30, 	35
	1000	1004	1008	100C	1010	1014	1018

int* iPtr1 = &arr[0];   -> same resuult == 1000
    	   = arr;		-> same resuult == 100
++iPtr1; // 1004 //iPtr1 is a pointer to ints. It starts at 1000.
Pointer offset notation.
Display iPtr1[2];


int arr[20] = { 5, 10, 15, 20, 25, 30, 35 };
int* iPtr1 = &arr[0];
++iPtr1;
printf("%zu\n", iPtr1[2]);
int* iPtr2 = arr[5]; 
// Could also go arr + 5 instead of arr[5] because it moves ahead 5 elements.




Stack, Static Data Area, Heap
-----------------------------

What is stored in each one?
Stack			|        The static data area        |       The Heap
automatic variables	| global and static local variables  | dynamically allocated variables using the functions malloc, calloc, and realloc.

The Stack:
Automatic variables - variables stored in a block.

The Static Data Area:
global and static local variables stored here.

The Heap:
Dynamically allocated variables stored here such as: malloc(), calloc(), and realloc().

In Java or C# when using the new operator to create objects, 
those objects are created on the heap.
The references for where you store where these objects are on the heap, are stored on the stack. 
References for those new objects are stored on the stack. 

If it doesn't have static in front, and is not a global, then it's an automatic.
Static local variables are initialized once. 

Global variables are always created before main starts execution. 

If we define an array the way we define most variables in C which is in a block, those are stored on the stack.
If you don't specify it's a global, which is outside the function, or you don't use the static keyword, 
and you don't allocate the memory dynamically using malloc, calloc or realloc, then it's an automatic. 
Automatics are stored on the stack.

Arrays explaining bytes and the stack:
c[0],   c[1],   c[2],   c[3],   c[4]
-45	6	0	72	1543

int x = 10;
int arr[6] = {10, 20, 30, 40};
...
...
...
arr[3] = 100;
arr + 3 x 4;

stack pointing down: (middle number is the stack)
x	| 10	| indexes below for the array
arr	| 10	| 0
	| 20	| 1
	| 30 	| 2
	| 40	| 3
	| 50	| 4
	| 60	| 6

The address of the very first number in the array is the address that is stored in memory.
The address 10 memory location for the array is what is stored in arr.
They have to be contiguous in memory. Arrays all have to be the same type because they have to be the same size.
If 10 is 4 bytes, then 20 must be 4 bytes, and 30 must be 4 bytes, and so on.
The reason for that is if we change arr[3] = 100.
So if arr[3] started at 40 as it does in the array above, then by changing index [3] to 100, 
the compiler has to write code to get us to the correct location of index 3, and the way it does that,
it says we start at the address stored in arr, which is the beginning of the 10 where the first byte is,
the address stored in arr is the address of the very first byte, then the compiler will go:
arr + 3 times the size of each element. It starts at 10, then goes 3 positions ahead times 4 bytes memory for each,
so it becomes arr + 3 x 4 = 12 bytes ahead. 


End stack and heap
------------------------------------------



Using Character Arrays to Store and Manipulate Strings
------------------------------------------------------



