%s13 is saying it's a field size of 13 that'll be displayed.


Conversion types
-------------------
Data type	printf conversion specification		scanf conversion specification
long double	%lf					%Lf
double 		%f					%lf
float		%f					%f

Integer types
Data type		printf conversion specification		scanf conversion specification
unsigned long long int	%llu					%llu
long long int		%lld					%lld
unsigned long int	%lu					%lu
long int		%ld					%ld
unsigned int		%u					%u
int 			%d					%d
unsigned short		%hu					%hu
short			%hd					%hd
char			%c					%c

double and float are the same with a print conversion specification in C.
They are not the same for scanf. They have to be different, and that is because what you pass to
scanf is an address, and you can't tell by looking at the address whether it's a double or a float.
It tells whether it's a double or a float by the conversion specification. 
scanf is given an address with the address of operator. 
array names are pointers.


In C, a void * (void pointer) cannot be directly dereferenced because 
it does not have a specific data type associated with it. 
The purpose of a void * pointer is to provide a generic pointer type 
that can point to objects of different data types.



sizeof long double returns an integer value.
sizeof returns the size of something in bytes. an object's or type's size in bytes.
sizeof returns as a sze_t value the array's total number of bytes.
sizeof is a compile-time operator, so it does not incur any execution-time overhead (except for VLAs).
size_t is based on another type - usually an unsigned int, it will be unsigned.



Random Facts
-------------------
Inline option is available in C and C++ as well.

int maximum(int x, int y, int z);
The parameters to maximum are three ints.
scanf("%d%d%d", &number1, &number2, &number3);
The arguments to maximum in main when we invoke or call it are number1, number2, and number3.
The values passed are the arguments, the type that the function is expecting is the parameters.
The parameters are through the ints of this function prototype.
The 3 arguments passed to maximum are passed by value. 
printf("Maximum is: %d\n", maximum(number1, number2, number3);
Maximum returns 1 int, so it prints 1 int with %d. It will return the max of the three values.

When you pass by value you are passing a copy, not the original.
When you pass by reference you pass the original.
If I give a friend a 1000 dollar bill that asks to see it, I give him the 1000 dollar bill.
That is passed by reference, because I gave him the original 1000 dollar bill. Once he is done
with the bill, another person overhears this conversation and asks to see the 1000 dollar bill.
I do not know this person and do not trust them compared to my friend, so I give him a photocopy
of the 1000 dollar bill, and I give him the copy. That is passed by value.  
In C the only way you can pass by reference is by using pointers.
Array names are pointers. 


Storage Classes
-------------------
C provides storage-class specifiers
	auto
	register
	extern
	static
A storage class determines an identifier's storage duration, scope, and linkage.
Storage duration is the period during which an identifier exists in memory.
Scope determines where a program can reference an identifier.
Labels are identifiers followed by a colon such as start:
Labels are the only thing that have function scope. Labels are used in goto statements.



Function Prototypes
-------------------
int square(int number);  // function prototype
The prototype only says what the name of the function is, what the parameters are,
what type they are and what order they are if there's more than one, 
example int and a double, and what type is returned. 
	- what the name of the function is
	- what the parameters are
	- what type is returned

int square(int number) { // implementation below main
	return number * number;
}
The prototype is only necessary if the implementation is below the main.
If the implementation is above the main, the prototype is not necessary.
The compiler would know all about the function including what it does.
Functions can be implemented in separate .c files.


size_t
-----
char and integer are compatible. All characters are an integer value of 0 to 128 for the normal ascii character values as an unsigned integer.
size_t represents an unsigned integral type recommended for variables representing an array's size or subscripts
size_t is defined in header <stddef.h>
size_t is converted with specificion %zu

char c one spot in memory - add 3 characters into that and it does out of bounds. 
getchar() returns 1 character. 
int s = 13; // type 13 things
int x;
while (s--) {
  x = getchar(x);
putchar(x);
}

getchar() gives back the ASCII code of the character that it returned. it returns 1 integer. 
However, if multiple characters are pressed, it will stack them up until the end of file, which is character ascii value 10. 
Return -1 in C means it didn't find anything, therefore a bad character.

Double quotes for string literals. Single quotes for single character.
int n[SIZE] = { 12, 15, 11, 7, 16 };
printf("%s%13s%17s\n", "Element", "Value", "Bar Chart\n");
for (size_t i = 0; i < SIZE; i++) { // size_t for the array.
	printf("%7zu%13d%8s", i, n[i], "");
	for (int j = 1; j <= n[i]; ++j) {
		printf("%c", '*');
	}
}


Arrays
----------------
Array names are pointers. 
Pointers contain addresses. Pointers are used to store addresses.
The address is displayed in hexadecimal - base 16.
A hex digit which is base 16, goes from 0 to 15. It goes back to 0 again after F.
4 bits can be represented by exactly one hex digit. 
If you output a 32-bit address, 4 into 32 goes 8 hex digits.
If you represent a 64-bit address, 4 goes into 64 16 times, it will display 16 hex digits/base 16 digits.

Array Facts
-----------
Arrays are static entities in that they remain the same size throughout program execution.
Arrays are group of memory locations related by the fact they all have the same array name 
and the same data type.
In the statement: ++frequency[responses[ answer ]];
answer is used as an index to access the 'responses' array, which likely holds a set of answers
or responses. The value obtained from responses[answer] is then used as an index to access the 
frequency array, which typically represents a counter for each response. The ++ operator increments
the counter associated with the response identified by responses[answer]. This is a common technique
for tallying responses in surveys or similar applications.
answer is a variable used as an index to access an element in the responses array. It retrieves a 
specific response. responses[answer] is correct.



%p outputs addresses as hexadecimal - this is compiler dependent.

The 2d is actually a one dimensional array in memory, where one row ends, another row starts.


int arr[10]; if we start with an array, and we want to pass this array to a function such as:
	 an array of ints
	 row       size
void func(int a[], size_t sz)
We need the subscript brackets but we don't specify the size, the value is ignored, other than to make sure it's greater than 0.
If we had a 2 dimensional array below:
        rows, columns
int arr2[3][4];  
void func2(int b[][4], size_t nRows) // when passing the array one line above to this function, we do not need to specify the number of rows, we do need to specify the columns.
The 2d array must have 4 columns for it to work. 
	b[1][2] = 20; // stores 20 in 1, 2
	location = starting loc + row * numberofcols + col
				  1   * 4            + 2   = 6 locations further than the start

	Column 0	Column 1	Column 2	Column 3
Row 0	a[0][0]		a[0][1]		a[0][2]		a[0][3]
Row 1	a[1][0]		a[1][1]		a[1][2]		a[1][3]
Row 2	a[2][0]		a[2][1]		a[2][2]		a[2][3]

Can initialize a multidimensional array when it's defined:
int array[2][2] = {{1, 2}, {3, 4}};
Then looped with a nested for loop.
void printArray(int a[][3]) {
	for (size_t r = 0; r <= 1; ++r) {
		for (size_t c = 0; c <= 2; ++c) {
			printf("%d ", a[r][c]);
		}
		puts("");
	}
}	




Random 
----------------
Random in C - included in <stdlib.h> library
scale	shift 	1-6
rand()%6 // rand modulus 6 add one
// Whatever the mod number is is how many numbers you will generate.
rand()%6 + 1
0 <------> 5
v	   v
1 <------> 6
for (int i = 5; i <= 5; i++) {
	printf("%d ", 1 + (rand() % 6)); // output 6 6 5 5 6 every time
} 
// having the same output can be a good thing for debugging.
We get the same results every time we run it because we are running the exact same code.
Even though this rand is supposed to be generating random values, and to some degree it
does, it's generating the same random values every time. 
When rand is invoked the first time, it produces a random number.
It uses a formula, a table lookup, and it also uses the seed.
rand() --> rand #1 
rand() --> rand #2 // uses the same formula, uses the same table, but does not use the same seed.
// #2 uses the seed as the previous seed
rand() --> rand #3 // when called the third time, it uses the same seed as #2
These rands produce the original value produced by rand, before doing any scaling on it.

If you need to seed the random number generator, only do it once at the top.
printf("%s", "Enter seed: ");
int seed = 0;
scanf("%d", &seed);
srand(seed); // seed the random number generator
To randomize without entering a seed each time, use a statement like:
srand(time(NULL));
This causes the computer to read its clock to obtain the value for a seed automatically.
Function time returns the number of seconds that have passed since midnight on January 1st, 1970.
The function prototype for time is in <time.h>

5 <---------------> 20
If you want random values between 5 and 20, subject the smaller from the larger, it would be 15.
It's not 15, it is 16. 
rand() % 16 // values from 0 to 15. It adds 1.
0 <---------------> 15
rand() % 16 + 5
5 <---------------> 20

-5 to +5
rand() % 11 // 11 values in total including 0. 0 counts as one of the values.
-5 to +5 needs 10 + 1 values to include the 0.
rand() % 11
0 <--------> 10 // this gives us 0 to 10, but we want -5 to +5.
Subtract 5
-5 <-------> 5
rand() % 11 - 5

3, 5, 7, 9, 11 // I want to randomly generate these values.
rand() % 5 // count the total number of values on the line above.
0, 1, 2, 3, 4  // these are the values that we now have with % 5.
But we want 3, 5, 7, 9, and 11.
Multiply the modulos 5 by 2.
0, 2, 4, 6, 8
Then add 3.
1, 5, 7, 9, 11
rand() % 5 * 2 + 3;



Pointers
--------
Pointers have one use and one use only - that is to store an address.
Every instruction has its own unique address, every variable has its own unique address.
When we pass by reference, what we do is pass the address of whatever it is we want to pass by reference.
The receiving function can go directly to that address and read the value or modify the value.
In C, the only way to pass by reference is using pointers. 

x: 10	10FE0		int x = 10;
	...		int * iPtr = NULL; // this * is a definition, it is defining iPtr 
iPtr	10FE3		iPtr = &x; 	   // "address of" operator
	10FE4		display x; 	   // displays 10
	...		display iPtr	   // displays 10FE0, this is stored in iPtr
	10FE7		display *iPtr	   // the * here is the indirection operator. we are using iPtr, but iPtr already exists, 
					   // the * above is now used in an executable statement.
					   // the indirection operator dereferences the pointer. 
Dereference means it goes to where the pointer is pointing, it references the value that's there, which is 10.
It will output 10.
			*iPtr = 20;	   // indirection operator on iPtr, left hand side of assignment operator.
				 	   // assigns 20 to x.
			This assignment using * is the same as display *iPtr. 
			display &iPtr;	   // where is iPtr stored in memory? the very first byte.
					   // 10FE4 will be output.
			double *dPtr, dPtr2 // dPtr2 will be a regular double unless it has an * in front.


Pointers
--------
void can be assigned to a pointer of any type. a void* is a generic or untyped pointer that can point to objects of any type.



Function Pointers
-----------------
int sum(int x, int y) {
  return x + y;
}

int prod(int x, int y) {
  return x * y;
}

void shoudNotBeChanged(int (*operation)(int, int)) {
  srand(time(NULL));
  int a = rand() % 100;
  int b = rand() % 100;
  printf("Result between %d and %d is %d\n", a, b, operation(a, b));
}

int main() {
  shouldNotBeChanged(*sum);
}
-----------------


Pointer Arithmetic Operators
-----------------
Assigning Pointers to one another
	* Pointers of the same type may be assigned to one another
int arr[20] = {5, 10, 15, ...};
index 	0	1	2	3	4	5	6
arr	5, 	10, 	15, 	20, 	25, 	30, 	35
	1000	1004	1008	100C	1010	1014	1018

int* iPtr1 = &arr[0];   -> same resuult == 1000
    	   = arr;	-> same resuult == 100
++iPtr1; // 1004 //iPtr1 is a pointer to ints. It starts at 1000.
Pointer offset notation.
Display iPtr1[2];


int arr[20] = { 5, 10, 15, 20, 25, 30, 35 };
int* iPtr1 = &arr[0];
++iPtr1;
printf("%zu\n", iPtr1[2]);
int* iPtr2 = arr[5]; 
// Could also go arr + 5 instead of arr[5] because it moves ahead 5 elements.


Stack, Static Data Area, Heap
-----------------------------

What is stored in each one?
Stack			|        The static data area        |       The Heap
automatic variables	| global and static local variables  | dynamically allocated variables using the functions malloc, calloc, and realloc.

The Stack:
Automatic variables - variables stored in a block.

The Static Data Area:
global and static local variables stored here.

The Heap:
Dynamically allocated variables stored here such as: malloc(), calloc(), and realloc().

In Java or C# when using the new operator to create objects, 
those objects are created on the heap.
The references for where you store where these objects are on the heap, are stored on the stack. 
References for those new objects are stored on the stack. 

If it doesn't have static in front, and is not a global, then it's an automatic.
Static local variables are initialized once. 

Global variables are always created before main starts execution. 

If we define an array the way we define most variables in C which is in a block, those are stored on the stack.
If you don't specify it's a global, which is outside the function, or you don't use the static keyword, 
and you don't allocate the memory dynamically using malloc, calloc or realloc, then it's an automatic. 
Automatics are stored on the stack.

Arrays explaining bytes and the stack:
c[0],   c[1],   c[2],   c[3],   c[4]
-45	6	0	72	1543

int x = 10;
int arr[6] = {10, 20, 30, 40};
...
...
...
arr[3] = 100;
arr + 3 x 4;

stack pointing down: (middle number is the stack)
x	| 10	| indexes below for the array
arr	| 10	| 0
	| 20	| 1
	| 30 	| 2
	| 40	| 3
	| 50	| 4
	| 60	| 6

The address of the very first number in the array is the address that is stored in memory.
The address 10 memory location for the array is what is stored in arr.
They have to be contiguous in memory. Arrays all have to be the same type because they have to be the same size.
If 10 is 4 bytes, then 20 must be 4 bytes, and 30 must be 4 bytes, and so on.
The reason for that is if we change arr[3] = 100.
So if arr[3] started at 40 as it does in the array above, then by changing index [3] to 100, 
the compiler has to write code to get us to the correct location of index 3, and the way it does that,
it says we start at the address stored in arr, which is the beginning of the 10 where the first byte is,
the address stored in arr is the address of the very first byte, then the compiler will go:
arr + 3 times the size of each element. It starts at 10, then goes 3 positions ahead times 4 bytes memory for each,
so it becomes arr + 3 x 4 = 12 bytes ahead. 


End stack and heap


Using Character Arrays to Store and Manipulate Strings
------------------------------------------------------
char strin1[] = "first"; initializes the elements of array string1 to the individual characters in the string literal "first".
Size is based on the string's length.
The string "first" contains five characters plus a string-terminating null character, string1 actually contains six elements.
All strings end with the \0 (null) character.
A character array representing a string should always be defined large enough to hold the string's number of characters and the terminating null character.

| 0000 0000 | 
char digit;
int d = digit - 48;
48 - 48 = 0 character digit 0
49 - 48 = 1
The null terminating character is a signal that you've reached the end of the string.
0 == NULL == '\0' //without the backslash, the 0 would be the ASCII value for 0, which is 48.

char string2[20];
scanf("%19s", string2);  
The reason we put 19 instead of 20 is because scanf automatically puts a null at the end.
If we allowed 20 characters to be read in and a null at the end that would take up 21 
characters and that would overwrite the end of our array - the array of chars.
Remember: array names are pointers.
To display the contents of a string without a loop by using %s\n, string2.

----
static array init

static int array1[3]; static array of ints. static arrays are automatically initialized to 0. That's only because it's a static array.
Reminder: When passing arrays by reference, you are not passing a copy, you are passing the original.
If you have an array and try to pass by value (a copy), first of all you have to find room in the function you 
are calling for a copy of the array, and then you to copy the values from the function that's doing the calling to the function that's being called,
and if it's a large array it can take a long time to copy all the values over. 
In C, the way we pass array names is by pointers. We always pass arrays by pointers.



Strings
#include <string.h>

Some built-in functions:
isdigit	iscntrl	isspace	islower	isupper
isalpha	ispunct	isgraph	toupper	
isalnum	

char s1[20] = "Happy ";
char s2[] = "New Year ";
char s3[40] = "";
strcat concatenates all of s2 to s1

printf("strcat(s1, s2) = %s\n", strcat(s1, s2)); //output: happy new year
printf("strncat(s3, s1, 6) = %s\n", strncat(s3, s1, 6)); //removes 6 characters: output: happy
printf("strcat(s3, s1) = %s\n", strcat(s3, s1)); // output: happy happy new year

strcat strncat strlen


All lowercase letters have a higher value than uppercase. Uppercase A = 65, lowercase a = 97.

Three different functions that convert a string into a numeric value.
C standard includes strtoll (signed long long), strtoull (unsigned long long).
The three we need are:

double strtod(const char *nPtr, char **endPtr);						Converts the string nPtr to double
long strtol(const char *nPtr, char **endPtr, int base);				Converts the string nPtr to long.
unsigned long strtoul (const char *nPtr, char **endPtr, int base);	Converts the string nPtr to unsigned long.


Search Functions
---------
char *strchr(const char *s, int c);
size_t strcspn (const char *s1, const char *s2);

strstr returns the address of the first occurrence of a substring in a string.
const char *string1 = "adcdef";
const char *string2 = "def";
printf("The first occurrence is: "

Week 5

stdio is a file pointer that you automatically have acccess to when you include stdio.h.

Function prototype		Function description
int getchar(void);		Returns the next character from the standard input as an integer.
char *fgets(char *s,		Reads characers from the specified stream into the array s
	int n FILE *stream);	until a new line or EOF character is encountered, or until n-1
				bytes are read. 
int putchar(int c);		Prints the character stored in c and returns it as an integer.
int puts(const char *s);	Prints the string s followed by a newline character. Returns a
				nonzero integer if successful, or EOF if an error occurs.
int sprintf(char *s, 
	const char *format,..); Equivalent to printf, but the output is stored in the array s
				instead of printed on the screen. Returns the number of characters
				written to s, or EOF if an error occurs.
int sscanf(char *s, 
	const char *format,..); Equivalent to scanf, but the input is read from the array s rather
				than from the keyboard. Returns the number of items successfully read
				by the function, or EOF if an error occurs.
fscannf();			Reads from a file instead of the keyboard.

A recursive function automatically provides a stack for you.
Chapter 6 in the textbook for recursion.
// Using functions fgets and putchar
Recursive function tests a base case
Recursive function calls itself. If the base case is not true, then call the function again,
and again we test for the base case, and if it's not true, test again and again. Keep calling
until we reach the base case and do a return. This goes back to the most recent call, then do a
return, and go back to the second most recent call, then the third most recent call.
void reverse(const char* const sPtr);
int main(void) {
	char sentence[80] = "";
	puts("Enter a line of text: ");
	fgets(sentence, 80, stdin); // reads a line of text
	printf("\n%s", "The line printed backwards is:");
	reverse(sentence);
	puts("");
}

void reverse(const char * const sPtr) {
	if ('\0' == sPtr[0]) {
	return;
	}
else {
	reverse(&sPtr[1]);
	putchar(sPtr[0]);
   }
}
--------------


Memory functions of the String - Handling Library

*memchr		Locates the first occurrence
void *memchr (const void *s, int c, size_t n);

*memset		Copies (converted to unsigned char) into the first n bytes of the object pointed to by s, then returns a pointer to the result.
void *memset (void *s, int c, size_t n);


memcpy
*memcpy copes a specified number of bytes.
memcpy copies a specified number of bytes from the object pointed to by its second argument into the one pointed to by its first argument.
It can receive a pointer to any type of object. If two objects overlap, use memmove instead.
	char string1[17] = "";
	char string2[] = "Copy this string";
	memcpy(string1, string2, 17);
	puts(string1);

void *memcpy(void *s1, const void *s2, size_t n);
Copies n bytes from the object pointed to by s2 into the object pointed
to by s1, then returns a pointer to the resulting object.
When a function has a return type of void, it means that the function does not return any value to the caller. It doesn't produce a specific result.

In the specific case of the memcpy function you mentioned earlier, 
it returns a pointer to void (void*). This indicates that the function does return a result, 
but the type of the result is unspecified. It's a way to indicate that memcpy returns a 
pointer to a block of memory that holds the copied data, and the data type of that 
memory block is determined by the caller. In other words, the memcpy function itself 
doesn't know what data type it's copying; it just copies raw bytes.



----------------------------
Strings
#include <string.h>


strcat
strcat appends its second argument string to the string in its char array first arugment,
replacing the first argument's null '\0' charater. you must ensure the array used to store
the frist string is large enough to store the first second, the second string, and the null 
terminating character copied from the second string.

strncat appends a specified number of characters from the second string to the first string 
and adds a terminating null character.
char s1[20] = "Happy";
char s2[] = "New Year ";
char s3[40] = "";

printf("%s\n", strcat(s1, s2));
printf("%s\n", strncat(s3, s1, 6)); concatenate 6 characters of s1 to s3
printf("%s\n", strcat(s3, s1);
Outputs:
s1 = Happy
s2 = New Year
strcat(s1, s2) = Happy New Year
strncat(s3, s1, 6) = Happy
strcat(s3, s1) = Happy Happy New Year



strtok
strtok breaks a string into a series of tokens also called tokenizing the string. A token is
a sequence of characters separated by delimiters, such as spaces, or punctuation marks.
char string[] = "This is a sentence with 7 tokens";
char tokenPointer = strtok(string, " ");
while (tokenPointer != NULL) {
	printf("%s\n", tokenPointer);
	tokenPointer = strtok(NULL, " ");
}
Multiple calls to strtok are required to tokenize a string, assuming it contains more than one token.


strstr
strstr searches for the first occurrence of its second string argument in its first string argument.
If the second string is found in the first, strstr returns a pointer to the second string's location
in the first. 
const char* string3 = "abcdefabcdef";
const char* string4 = "def";
printf("The first occurrence is: %s\n", strstr(string3, string4));



strspn
strspn determines the length of the initial part of its first argument containing only characters 
from the string in the second argument. It returns the length of the segment. length %zu
const char* stringy1 = "the value of potato power is 3.14159 yes";
const char* stringy2 = "aehi lstuv";
printf("The length containing something something: %zu\n", strspn(stringy1, stringy2));
output: 10



strchr
strchr researches for the first occurrence of a character in a string. If the character is found,
strchr returns a pointer to the character in the string; otherwise strchr returns null.
const char *string = "this is a string of words";
char character1 = 'a';
if (strchr(string, character1) != NULL) {
	printf("'%c' was found in %s", character1, string);
} else {
	pritnf("'%c' was not found in %s", character1, string);
}


strrchr
strrchr searches for the last occurrence of the specified character in a string. If the character
is found, strrchr returns a pointer to the character in the string, otherwise, it returns NULL.
const char* strrchrSearch = "a zoo has many animals including zebras";
int c = 'z'; // character to search
printf("%s '%c' %s\n", "Remainder of chrSearch beginning with last occurrence:", c, strrchr(strrchrSearch, c));
Output: Remainder of chrSearch beginning with last occurrence: 'z' zebras



strpbrk
strpbrk searches its first string argument for the first occurrence of any character in its second string argument.
If a character from the second argument is found, strpbrk returns a pointer to the character in the
first argument; otherwise, it returns null.

Searches for the first occurrence in its first string argument of 
any character in its second string argument.

const char *string1 = "This is a test";
const char *string2 = "beware";

printf("%s\"%s\"\n'%c'%s \"%s\"\n", "Of the characters in ", string2, *strpbrk(string1, string2),
 " appears earliest in ", string1);
 }
output: Of the characters in "beware" 'a' appears earliest in "This is a test"



strspn calculates the length of the initial string that consists of characters
that match the specified set of characters. It returns the length of the substring
that contains only characters from the set.

strcspn
strcspn determines the length of the initial part of its first string argument 
that does not contain any characters from its second string argument. 
The function returns the segment's length.




strcmp returns 0 if its first argument is equal to its second argument, indicating that the two strings are the same. If the strings are not equal, it returns a value that is either negative or positive, depending on the lexicographical order of the characters that differ in the two strings.
It will return specifically 0 if both strings are the same.


strncmp compares up to n characters of its first argument with its second argument.


Which function would be the most useful for determining if a certain 
word is contained in a string representing a sentence?
strstr


Which function searches for the first occurrence in its first string 
argument of any character in its second string argument?
strpbrk


Which function allows characters of one part of a string to be 
copied into another part of the string?
memmove
memmove is used to copy a specified number of bytes from one location in 
memory to another, even if the source and destination regions overlap.


memcmp would return ___________ for the call
memcmp("Hi, how are you?", "Hi, how are things?", 6);
In this case, the first 6 characters of both strings are the same, 
so memcmp would return 0 to indicate that the compared portions are equal.
0


To change the string "ABCDEFGHI" to "aaaaaFGHI" 
you would use the _________ function.
memset

The memset function is used to set a block of memory with a specified value. 
In this case, you want to fill the first 5 characters of the string with 
'a' characters, which can be done using memset.


memcpy
Function memmove correctly handles the situation for which memcpy most 
notably fails.
In fact, it's the opposite. memmove is designed to handle situations 
where the source and destination memory regions overlap, 
ensuring a correct copy in such cases. memcpy, on the other hand, 
can produce incorrect results if the source and destination overlap. 
This is a key difference between the two functions.
memcpy




-----------------------------

Chapter 10 Strings

This is called a scan set.
char z[12] = "";
printf("%s", "Enter a string: ");
scanf(%11[aeiou]", z);
printf("The input was \"%s\"\n", z);
It will output all matching letters.

This is an inverted scan set - it finds the first instance not matching letters.
char z[12] = "";
printf("%s", "Enter a string: ");
scanf(%11^[aeiou]", z);
printf("The input was \"%s\"\n", z);
It will output all letters not in the brackets until it finds them.

char z[99] = "";
printf("%s", "Enter a string: ");
scanf(%99[^\n]", z);
printf("The input was \"%s\"\n", z); // does not read the newline

Inputting data with a field width.
int x = 0;
int y = 0;
printf("%s", "Enter a six digit integer: ");
scanf("%2d%d", &x, &y);
printf("The integers input were %d and %d\n", x, y);

Reading and discarding characters from the input stream
int month = 0;
int day = 0;
int year = 0;
printf("%s", "Enter a date in the form mm/dd/yyyy: ");
scanf("%d/%d/%d, &month, &day, &year); // skips the slash

printf("%s", "Enter a date in the form mm-dd-yyyy: ");
scanf("%d%*c%d%*c%d", &month, &day, &year);

printf("%s", "Enter a date in the form mm/dd/yyyy: ");
scanf("%d%*c%d%*c%d", &month, &day, &year);

printf("month = %d day = %d year = %d\n", month, day, year);
// it will discard any single character after it's read first int and second int
// * is a wild card



Structs and types
-----------------

Structures are sometimes referred to as aggregate data.
types are collections of related variables under one name.

Structs have some characteristics in common with classes.
Structs have members (also called attributes), sometimes called fields.
Defining a struct does not actually automatically create an instance of the struct.

structs differ from classes in the following ways:
- structs do not have methods
- which means that all of the members must be public (no such thing as encapsulation)
- there is no support for inheritance
- there is no support for polymorphism

struct Time1 {
    int hour;
    int min;
    int sec;
} t1, tArr[10], *tPtr;

How many bytes in t1?
12
How many bytes in tArr[10]?
120
How many bytes in *tPtr? 8 because it's a 64 bit app.
8
it would be 4 bytes in a 32 bit app.

-----------------

struct { 
	int hour;
	int min;
	int sec;
} t3, tArr3[10], *tPtr3;
This will access members of the struct even though it does not have a tag. (name).
t3.hour = 10;
t3.min = 59; // get variable the pointer is pointing to
t3.sec = 59;

tPtr3 = &tArr3[5];
tPtr3->hour = 20;
tPtr3->min = 20;
tPtr3->sec = 20;

tPtr3 = &tArr3[9];  // not good practice
(*tPtr3).hour = 15; // not the way to do it
(*tPtr3).min = 15;  // pointer above is better
(*tPtr3).sec = 15;  

t3 = tArr3[5] // member wise assignment


	   t3 = tArr3[5]; what this does is a member-wise assignment, also called a shallow assignment.
	t3		tArr3[5]
hour 	10		20	hour	
min	59		20	min
sec	59		20	sec
It does a member by member assignment
	    <---------
So it becomes: and copies the members of tArr3 to t3
hour	20		20 	hour
min	20		20 	min
sec	20		20	sec

struct employee {
	char firstName[20];
	char lastName[20];
	unsigned int age2;
	char gender;
	double hourlySalary;
};
struct card {
    char *face;
    char *suit;
};
main
struct card aCard;
struct card *cardPtr;
-----------






Unions
-----------
Unions were introduced in the early days of the C language to save on memory.
They are very similar a struct - there is only one major difference between a union and a struct.
Unions are defined the same way structs are defined, except one major major difference.
And that difference is at any one time, you can only use one of the members. 
The number of bytes that is a union is simply the size of the largest member. The largest member specifies the size of the union.
In most cases unions contain two or more data types. It wouldn't make sense for a union to have only one data type.
If it had only one data type you may as well make it a struct.

union number { // create a union called number
    int x;	4 bytes because of int
    double y;	8 bytes because of double
}; // end union number


Bitwise operators
bitwise AND (&), bitwise inclusive OR (|), bitwise exclusive OR (^), aka bitwise XOR,
left shift (<<), right shift (>>), and complement (~).


Legend: 
& = AND, | = inclusive OR, ^ = exclusive or, ~ = 1's complement.
  0011	  0011	  0011	  
  0101	  0101	  0101	  0101
------------------------------
& 0001	| 0111	^ 0110 	~ 1010

	0011	1100	1111	0101	<< 4 // left shift 4 bits 
	----------------------------
becomes 1100	1111	0101	0000	// 1100 (left side) will be lost
 	
	0011	1100	1111	0101	>> 4 // shift right 4 bits
	----------------------------
becomes 0000	0011	1100	1111	// 0101 (right side) will be lost





Dynamic Memory Allocation
-------------------------




Linked Lists
------------

A node can contain data of any type including other struct objects.
Stacks and queues are also linear data structures, and are constrained versions of linked lists.



File Reading
------------

r = Open an existing file for reading. If it cannot find the file, it returns NULL. The file must exist, otherwise it returns an error condition.
w = Create a file for writing. If the file already exists, discard the current contents.
a = Append; open or create a file for writing at the end of the file.
r+ = Open an existing file for update (reading and writing).
w+ = Create a file for update. If the file already exists, discard the current contents.
a+ = Append: open or create a file for update; writing is done at the end of the file.


Read/Write functions in the standard library
fgetc
• Reads one character from a file
• Takes a FILE pointer as an argument (all of these take a file pointer).
• fgetc(stdin) is equivalent to getchar()

fputuc
• Writes one character to a file
• Takes a FILE pointer and a character to write as an argument
• fputc( 'a', stdout ) equivalent to putchar( 'a' )

fgets
• Reads a line from a file

fputs
• Writes a line to a file

fscanf / fprintf
• File processing equivalents of scanf and printf

fprintf
• Used to print to a file
• Like printf, except the first argument is a FILE pointer (pointer to the file you want to print in)

feof (FILE pointer)
• Returns trie if end-of-file indicator (no more data to process) is set for the specified file

fclose(FILE pointer)
• CLoses specified file
• Performed automatically when program ends
• Good practice to close files explicitly

Details
- Programs may process no files, one file, or many files
- Each file must have a unique name and should have it own pointer
This means to use different pointers for different files instead of using the same pointer for different files.

Reading a sequential access file
- Create a FILE pointer, link it to the file to read
      cfPtr = fopen("clients.txt", "r");
- Use fscanf to read from the file
    • Like scanf, except first argument is a FILE pointer
    fscanf(cfPtr, "%d%s%f", &acount, name, &balance);
- Data read from beginning to end
- File position pointer
    • Indicates number of next byte to be read / written
    • Not really a pointer, but an ineger value (specifies byte location)
    • Also called byte offset
- rewind(cfPtr)
    • Repositions the file position pointer to beginning of file (byte 0)

Sequential access file
- Cannot be modified without the risk of destroying other data
- Fields can vary in size
    • Different representation in files and screen than internal representation
    • 1, 34, -890 are all ints, but have different sizes on disk






